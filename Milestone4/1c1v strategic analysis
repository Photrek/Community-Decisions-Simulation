//bringing the tools
#include <stdlib.h>
#include <stdio.h>
#include <time.h>
#include <math.h>
#include <string.h>

//system parameters

//number of individuals
#define N 500

//number of experiments
#define Nxps 20000

//Number of experiments to write data in txt files
#define backUpRate (1000) 

//Using several threads to run the simulation
#define Nstages (24)

//social Inertia
#define AverageInertia (0.100)

//proportional constant of the business model of inertia 
#define InertiaProp (3)

//probability of an indiviudal postint a rate in the platform
#define Pposting (0.4)

//parameter that controls how the number of people rating one proposal impacts the nonconformity inertia of the other users.
#define socialPressure (0.01)

//number of proposals available to vote
#define Nproposals (20)
//#define MaxFundedProposals (Nproposals)

//probability of an user skiping a proposal. If the user do not skip, it makes a grade from 1 to 10 to the proposal and vote on it.
#define Pskip (0.05)

//in plurality voting with quadratic costs, the agents choose only a few proposals to vote on.
//#define NmaxProposalsToVote (Nproposals)

//average Total Funding from rounds 1 to 4.
//(ignoring round 4 beta who had a smaller total funding money).
//#define fundingMoney (1137500)
#define af 43*1000000
#define bf 6*10000
//#define kf 83146.479491035
#define fundingMoney (af + bf*Nproposals)
//#define fundingMoney (kf*Nproposals)

//fraction of agents who will vote grade 10 on their favorite proposals, and vote 1 on the remaining proposals
#define fi (0.00)
#define ff (1.00)
#define df (0.05)

//balance distribution parameters
#define AL  (-3.4)
#define balanceMin (0.3)

//funding request distribution parametersÃ¥
#define yo (0.0000045)
#define A (0.000051)
#define xo (9000.0)
#define minFunding (1000)

//coupled gaussian parameters
#define kappa (2.0) //related to comunity extremism level
#define muMin (-100.0) //related to the community average opinion on the proposal
#define muMax (100.0) //related to the community average opinion on the proposal
#define sigma (1.0)//related to community noise in interpreatating the proposals

//strategic voting parameter
#define Ki 1
#define Kf 4
#define dK 1

//global System variables
long double Inertia[N], rating[N][Nproposals], proposalRating[Nproposals] ;
long double voting_rating[N][Nproposals];
int NumberRatings[Nproposals],  IndividualVotes[Nproposals];
long double money[N], funding[Nproposals], proposalVotes[Nproposals], Impact[Nproposals];
long double totalSQRTmoney, totalMoney;
int MostVotedProposals[Nproposals], NfundedProposals;
int fundedProposals[Nproposals];
long double f, moneyMin, moneyMax;
int favoriteProposals[N][Nproposals], proposalsToVote[N][Nproposals];
int stage, stagesNeeded;
int agentType[N];
long double max_sentiment[N], min_sentment[N], MoneyPercent[Nproposals];

long double W;
long double WextFully, WextFullyStrategic, WextFullyNonstrategic;
long double WextFullySkip, WextFullySkipStrategic, WextFullySkipNonstrategic;
long double Wext[Kf], WextStrategic[Kf], WextNonStrategic[Kf];
long double WextSkip[Kf], WextSkipStrategic[Kf], WextSkipNonStrategic[Kf];
long double Weco[Kf], WecoStrategic[Kf], WecoNonStrategic[Kf];
long double WecoExtreme[Kf], WecoExtremeStrategic[Kf], WecoExtremeNonStrategic[Kf];

//arquive variables
char txt[200];
FILE *fp;
FILE* read; 
char character;
char write[300];

//random number
#define rn ((float)(rand()))/(float)(RAND_MAX)

struct STAGE
{
	float INITIAL;
	float FINAL;
};

//finding the initial points from the simulation of each thread
struct STAGE POINTS(float initial_point, float final_point, float increment, int number_stages)
{    
	struct STAGE POINT;
	
	int Npoints_total, Npoints_per_stage;
	
	Npoints_total = round((final_point - initial_point)/increment) + 1;
	
	Npoints_per_stage = round((double)Npoints_total/number_stages);
	
	if(Npoints_per_stage == 0)
		stagesNeeded = 1;
	else
		stagesNeeded = ceil((float)Npoints_total/Npoints_per_stage);
	
	if(stagesNeeded > Nstages)
		stagesNeeded = Nstages;
	
	printf("please, set the simulation stage as a integer between 1 and %d:", stagesNeeded);
	scanf("%d", &stage);
	
	//predicting initial and final points of each stage with lorenz corrections
	POINT.INITIAL = initial_point + (stage-1)*Npoints_per_stage*increment;
	POINT.FINAL = initial_point + (stage*Npoints_per_stage -1)*increment + 0.5*increment;
	if(stage == Nstages || stagesNeeded == 1)
		POINT.FINAL = final_point + 0.5*increment;
	return (POINT);
}
//cumulative of the exponential function
long double ExponentialCumulative(long double x)
{
	return yo*x - A*xo*exp(-x/xo) + A*xo;
}

//generator of random numbers following a exponential distribution using Inverse Transform Sampling.
long double randomExponential()
{
	long double randomNumber = rn;
	
	long double expoRN = 0;
	long double dExpoRn = 0.1;
	while(ExponentialCumulative(expoRN) < randomNumber)
		expoRN += dExpoRn;
	
	return minFunding + expoRN - dExpoRn;
}

//requested proposal fundings
void RequestFundingDistribution()
{
	for(int proposal = 0; proposal < Nproposals; proposal++)
		funding[proposal] = randomExponential();
}

//generator of random numbers following a power law distribution using Inverse Transform Sampling.
long double randomPowerLaw()
{
	return balanceMin*pow((1 - rn), 1.0/(AL+1));
}

void Money_Distribution()
{	
	totalMoney = 0.0;
	totalSQRTmoney = 0.0;
	for(int i=0; i <N; i++)
	{
		//how much balance/tokens each agent has
		money[i] = pow(10, randomPowerLaw());
		
		totalMoney += money[i];
		totalSQRTmoney += sqrt(money[i]);
		//money[i] = 100*ratingMax(i)/5.0;
	}
}

void InertiaDistribution()
{
	for(int i = 0; i < N; i++)
	{
		Inertia[i] = AverageInertia;
	}

	for(int i = 0; i < N; i++)
	{
		long double peopleWithLessMoney = 0; 
		
		for(int j = 0; j < N; j ++)
		{
			if(money[j] < money[i])
				peopleWithLessMoney++;
		}
		
		Inertia[i] = Inertia[i]*(1 + InertiaProp*peopleWithLessMoney/(N-1));
		
		if(Inertia[i] > 1)
			Inertia[i] = 1;
	}
}

//calculate the weight of a grade. More extreme grades cost more.
//maps grades {1, 2, ,3 ,4 5, 6, 7, 8, 9, 10} to weights {5. 4, 3, 2, 1, 1, 2, 3, 4, 5}.
long double LinearGradeWeight(long double grade)
{
	if(grade <= 5)
		return 6 -grade;
	else
		return grade - 5;
}

//calculate the weight of a grade. More extreme grades cost more.
//maps grades {1, 2, ,3 ,4 5, 6, 7, 8, 9, 10} to weights {25, 16, 9, 4, 1, 1, 4, 9, 16, 25}.
long double QuadraticGradeWeight(long double grade) 
{
	if(grade <= 5)
		return pow((6-grade), 2);
	
	else
		return pow((grade - 5), 2);
}

//calculate the weight of a grade. More extreme grades cost more.
//maps grades {-10, -9, -8, -7, -6, -5, -4, -3, -2, -1, 1, 2, ,3 ,4 5, 6, 7, 8, 9, 10} to weights {100, 81, 64, 49, 36, 25, 16, 9, 4, 1, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100}.
long double QuadraticGradeWeightWithNegatives(long double grade) 
{
	return pow(grade, 2);
}

long double LinearGradeWeightWithNegatives(long double grade) 
{
	return fabsl(grade);
}

long double kappa_log(long double x, long double kappa_distro) 
{
	if (kappa == 0) 
		return log(x);
	
	else 
		return (pow(x, kappa) - 1) / (kappa);
}

long double coupled_gaussian(long double kappa_distro, long double mu_distro, long double sigma_distro) 
{
	long double U1 = rn;
	long double U2 = rn;
	
	long double R = sqrt(kappa_log(pow(U1, -2), kappa));
	long double theta = 2 * M_PI * U2;
	
	long double Z = R * cos(theta);  // One of the possible q-Gaussian variables
	return mu_distro + sigma * Z;
}

void ProposalDynamics()
{
	for(int proposal = 0; proposal < Nproposals; proposal++)
	{
		long double mu_proposal = (rn < 0.5)? muMax*rn : muMin*rn;
		
		//number of people who voted on the proposal
		IndividualVotes[proposal] = 0;
		
		//determining the impact of each proposal on the community on a scale from 1 to 5
		//Impact[proposal] = RandomStar(rn);
		
		NumberRatings[proposal] = 0;
		proposalRating[proposal] = 0.0;
		
		int i = 0;
		while(NumberRatings[proposal] == 0 && i < N)
		{
			if(rn< Pskip)
				rating[i][proposal] = NAN;
			
			else
			{
				IndividualVotes[proposal]++;
				
				rating[i][proposal] = coupled_gaussian(kappa, mu_proposal, sigma);
								
				if(rn < Pposting)
				{
					proposalRating[proposal] += rating[i][proposal];
					NumberRatings[proposal]++;
				}
			}
			
			i++;
		}
		
		//now, the other agents will rate the proposal
		//one invidiual at a time
		//but they are influenced bu the average rating past users gave
		//how much an agent is influenced by the average majority
		//is modelled by the social validation parameter
		while(i < N)
		{
			if(rn < Pskip)
				rating[i][proposal] = NAN;
			
			else
			{
				IndividualVotes[proposal]++;
				
				//agent independent opinion
				rating[i][proposal] =  coupled_gaussian(kappa, mu_proposal, sigma);
								
				//average past majority rating
				long double averageOpinion = proposalRating[proposal]/(NumberRatings[proposal]);
				
				//social validation on inertia
				long double socialValidation = 1 - Inertia[i]*pow(1-socialPressure, NumberRatings[proposal]);

				//social validation effect
				if(rn < socialValidation)
					rating[i][proposal] += socialValidation*(averageOpinion - rating[i][proposal]); 
				
				//nonconformism
				else
				{
					rating[i][proposal] -= (1 - socialValidation)/(averageOpinion -  rating[i][proposal]);
				}
					
				if(rn < Pposting)
				{
					proposalRating[proposal] += rating[i][proposal];
					NumberRatings[proposal]++;
				}
			}

			i++;
		}
		
		//writing the final average rating values
		proposalRating[proposal] = proposalRating[proposal]/NumberRatings[proposal];
	}
}

void AgentsDistributionExtreme(int K)
{
	//initially, all agents are honest
	for(int i = 0; i < N; i++)
	{
		agentType[i] = 0;
		for(int proposal = 0; proposal < Nproposals; proposal++)
		{
			voting_rating[i][proposal] = rating[i][proposal];
		}
	}
		
	//now, we will select a fraction f of them to peform strategiv voting.
	int Nf = 0;
	int Ntarget = N*f;
	
	while(Nf < Ntarget)
	{
		int agent = rand()%N;
		
		if(agentType[agent] == 0)
		{
			agentType[agent] = 1;
			Nf++;
			
			//each of the strategic votings agents will vote wiht grade 10 on their top favorite proposals and will vote with grade 1 on the remaining proposals. Lets define their fake set of grades
			int preferredProposal[Nproposals];
			
			for(int proposal = 0; proposal < Nproposals; proposal++)
				preferredProposal[proposal] = proposal;
			
			//now, we make a copy of the ratings vector. We don't want to mess the original vector.
			long double copyRatings[Nproposals];
			for(int proposal = 0; proposal < Nproposals; proposal++)
				copyRatings[proposal] = rating[agent][proposal];
				
			//now, we will order the copy votes vector and the index (the proposals) using bubble sort. The goal is that the first entry of the MostVotedProposals will say the proposal number with most votes, and so on.
			for(int i = 0; i < Nproposals - 1; i ++)
			{
				for(int j = 0; j < Nproposals - 1 - i; j++)
				{
					if(copyRatings[j] < copyRatings[j+1])
					{
						long double store = copyRatings[j];
						copyRatings[j] = copyRatings[j+1];
						copyRatings[j+1] = store;
						
						int storeIndex = preferredProposal[j];
						preferredProposal[j] = preferredProposal[j+1];
						preferredProposal[j+1] = storeIndex;
					}
				}
			}
			
			int j = 0;
			int strategiedProposals = 0;
			while(j < Nproposals && strategiedProposals < K)
			{
				int proposal = preferredProposal[j];
				
				if(!isnan(rating[agent][proposal]) && rating[agent][proposal] > 0)
				{
					voting_rating[agent][proposal] = max_sentiment[agent];
					strategiedProposals++;
				}
				
				j++;
			}
			
			for(int proposal = 0; proposal < Nproposals; proposal++)
			{
				if(voting_rating[agent][proposal]!=max_sentiment[agent])
					voting_rating[agent][proposal] = min_sentment[agent];
			}
		}
	}
}

void AgentsDistributionFullyExtreme()
{
	//initially, all agents are honest
	for(int i = 0; i < N; i++)
	{
		agentType[i] = 0;
		for(int proposal = 0; proposal < Nproposals; proposal++)
		{
			voting_rating[i][proposal] = rating[i][proposal];
		}
	}
		
	//now, we will select a fraction f of them to peform strategiv voting.
	int Nf = 0;
	int Ntarget = N*f;
	
	while(Nf < Ntarget)
	{
		int agent = rand()%N;
		
		if(agentType[agent] == 0)
		{
			agentType[agent] = 1;
			Nf++;
			
			for(int proposal = 0; proposal < Nproposals; proposal++)
			{
				if(rating[agent][proposal] > 0)
					voting_rating[agent][proposal] = max_sentiment[agent];
				
				else
					voting_rating[agent][proposal] = min_sentment[agent];
			}
		}
	}
}

void AgentsDistributionFullyExtremeSkip()
{
	//initially, all agents are honest
	for(int i = 0; i < N; i++)
	{
		agentType[i] = 0;
		for(int proposal = 0; proposal < Nproposals; proposal++)
		{
			voting_rating[i][proposal] = rating[i][proposal];
		}
	}
		
	//now, we will select a fraction f of them to peform strategiv voting.
	int Nf = 0;
	int Ntarget = N*f;
	
	while(Nf < Ntarget)
	{
		int agent = rand()%N;
		
		if(agentType[agent] == 0)
		{
			agentType[agent] = 1;
			Nf++;
			
			for(int proposal = 0; proposal < Nproposals; proposal++)
			{
				if(rating[agent][proposal] > 0)
					voting_rating[agent][proposal] = max_sentiment[agent];
				
				else
					voting_rating[agent][proposal] = NAN;
			}
		}
	}
}

void AgentsDistributionExtremeSkip(int K)
{
	//initially, all agents are honest
	for(int i = 0; i < N; i++)
	{
		agentType[i] = 0;
		for(int proposal = 0; proposal < Nproposals; proposal++)
		{
			voting_rating[i][proposal] = rating[i][proposal];
		}
	}
	
	//now, we will select a fraction f of them to peform strategiv voting.
	int Nf = 0;
	int Ntarget = N*f;
	
	while(Nf < Ntarget)
	{
		int agent = rand()%N;
		
		if(agentType[agent] == 0)
		{
			agentType[agent] = 1;
			Nf++;
			
			//each of the strategic votings agents will vote wiht grade 10 on their top favorite proposals and will vote with grade 1 on the remaining proposals. Lets define their fake set of grades
			int preferredProposal[Nproposals];
			
			for(int proposal = 0; proposal < Nproposals; proposal++)
				preferredProposal[proposal] = proposal;
			
			//now, we make a copy of the ratings vector. We don't want to mess the original vector.
			long double copyRatings[Nproposals];
			for(int proposal = 0; proposal < Nproposals; proposal++)
				copyRatings[proposal] = rating[agent][proposal];
				
			//now, we will order the copy votes vector and the index (the proposals) using bubble sort. The goal is that the first entry of the MostVotedProposals will say the proposal number with most votes, and so on.
			for(int i = 0; i < Nproposals - 1; i ++)
			{
				for(int j = 0; j < Nproposals - 1 - i; j++)
				{
					if(copyRatings[j] < copyRatings[j+1])
					{
						long double store = copyRatings[j];
						copyRatings[j] = copyRatings[j+1];
						copyRatings[j+1] = store;
						
						int storeIndex = preferredProposal[j];
						preferredProposal[j] = preferredProposal[j+1];
						preferredProposal[j+1] = storeIndex;
					}
				}
			}
			
			int j = 0;
			int strategiedProposals = 0;
			while(j < Nproposals && strategiedProposals < K)
			{
				int proposal = preferredProposal[j];
				
				if(!isnan(rating[agent][proposal]) && rating[agent][proposal] > 0)
				{
					voting_rating[agent][proposal] = max_sentiment[agent];
					strategiedProposals++;
				}
				
				j++;
			}
			
			for(int proposal = 0; proposal < Nproposals; proposal++)
			{
				if(voting_rating[agent][proposal]!=max_sentiment[agent])
					voting_rating[agent][proposal] = NAN; //skip the proposal
			}
		}
	}
}

void AgentsDistributionEconomist(int K)
{
	//initially, all agents are honest
	for(int i = 0; i < N; i++)
	{
		agentType[i] = 0;
		for(int proposal = 0; proposal < Nproposals; proposal++)
		{
			voting_rating[i][proposal] = rating[i][proposal];
		}
	}
	
	//now, we will select a fraction f of them to peform strategic voting.
	int Nf = 0;
	int Ntarget = N*f;
	
	while(Nf < Ntarget)
	{
		int agent = rand()%N;
		
		if(agentType[agent] == 0)
		{
			agentType[agent] = 1;
			Nf++;
			
			//each of the strategic votings agents will vote wiht grade 10 on their top favorite proposals and will vote with grade 1 on the remaining proposals. Lets define their fake set of grades
			int preferredProposal[Nproposals];
			
			for(int proposal = 0; proposal < Nproposals; proposal++)
				preferredProposal[proposal] = proposal;
			
			//now, we make a copy of the ratings vector. We don't want to mess the original vector.
			long double copyRatings[Nproposals];
			for(int proposal = 0; proposal < Nproposals; proposal++)
				copyRatings[proposal] = rating[agent][proposal];
				
			//now, we will order the copy votes vector and the index (the proposals) using bubble sort. The goal is that the first entry of the MostVotedProposals will say the proposal number with most votes, and so on.
			for(int i = 0; i < Nproposals - 1; i ++)
			{
				for(int j = 0; j < Nproposals - 1 - i; j++)
				{
					if(copyRatings[j] < copyRatings[j+1])
					{
						long double store = copyRatings[j];
						copyRatings[j] = copyRatings[j+1];
						copyRatings[j+1] = store;
						
						int storeIndex = preferredProposal[j];
						preferredProposal[j] = preferredProposal[j+1];
						preferredProposal[j+1] = storeIndex;
					}
				}
			}
						
			int j = 0;
			int strategiedProposals = 0;
			int strategic[K];
			while(j < Nproposals && strategiedProposals < K)
			{
				int proposal = preferredProposal[j];
				
				if(!isnan(rating[agent][proposal]) && rating[agent][proposal] > 0)
				{
					strategic[strategiedProposals] = proposal;
					strategiedProposals++;
				}
				
				j++;
			}
						
			for(int proposal = 0; proposal < Nproposals; proposal++)
			{
				int found = 0;
				for(int j = 0; j < strategiedProposals; j++)
				{
					if(strategic[j] == proposal)
						found = 1;
				}
				
				if(found == 1)
					voting_rating[agent][proposal] = rating[agent][proposal];
				
				else
					voting_rating[agent][proposal] = NAN;
			}
		}
	}
}

void AgentsDistributionEconomistExtreme(int K)
{
	//initially, all agents are honest
	for(int i = 0; i < N; i++)
	{
		agentType[i] = 0;
		for(int proposal = 0; proposal < Nproposals; proposal++)
		{
			voting_rating[i][proposal] = rating[i][proposal];
		}
	}
	
	//now, we will select a fraction f of them to peform strategic voting.
	int Nf = 0;
	int Ntarget = N*f;
	
	while(Nf < Ntarget)
	{
		int agent = rand()%N;
		
		if(agentType[agent] == 0)
		{
			agentType[agent] = 1;
			Nf++;
			
			//each of the strategic votings agents will vote wiht grade 10 on their top favorite proposals and will vote with grade 1 on the remaining proposals. Lets define their fake set of grades
			int preferredProposal[Nproposals];
			
			for(int proposal = 0; proposal < Nproposals; proposal++)
				preferredProposal[proposal] = proposal;
			
			//now, we make a copy of the ratings vector. We don't want to mess the original vector.
			long double copyRatings[Nproposals];
			for(int proposal = 0; proposal < Nproposals; proposal++)
				copyRatings[proposal] = rating[agent][proposal];
				
			//now, we will order the copy votes vector and the index (the proposals) using bubble sort. The goal is that the first entry of the MostVotedProposals will say the proposal number with most votes, and so on.
			for(int i = 0; i < Nproposals - 1; i ++)
			{
				for(int j = 0; j < Nproposals - 1 - i; j++)
				{
					if(copyRatings[j] < copyRatings[j+1])
					{
						long double store = copyRatings[j];
						copyRatings[j] = copyRatings[j+1];
						copyRatings[j+1] = store;
						
						int storeIndex = preferredProposal[j];
						preferredProposal[j] = preferredProposal[j+1];
						preferredProposal[j+1] = storeIndex;
					}
				}
			}
						
			int j = 0;
			int strategiedProposals = 0;
			int strategic[K];
			while(j < Nproposals && strategiedProposals < K)
			{
				int proposal = preferredProposal[j];
				
				if(!isnan(rating[agent][proposal]) && rating[agent][proposal] > 0)
				{
					strategic[strategiedProposals] = proposal;
					strategiedProposals++;
				}
				
				j++;
			}
			
			long double totalOpinion = 0.0;
			for(int j = 0; j < strategiedProposals; j ++)
			{
				int proposal = strategic[j];
				
				totalOpinion += rating[agent][proposal];
			}
			
			for(int proposal = 0; proposal < Nproposals; proposal++)
			{
				int found = 0;
				for(int j = 0; j < strategiedProposals; j++)
				{
					if(strategic[j] == proposal)
						found = 1;
				}
				
				if(found == 1)
					voting_rating[agent][proposal] = rating[agent][proposal]/totalOpinion;
				
				else
					voting_rating[agent][proposal] = NAN;
			}
		}
	}
}

void FindMaximumSentments()
{
	for(int i = 0; i < N; i++)
	{
		max_sentiment[i] = -INFINITY;
		min_sentment[i] =  INFINITY;
		
		for(int proposal = 0; proposal < Nproposals; proposal++)
		{
			if(!isnan(rating[i][proposal]))
			{
				if(rating[i][proposal] > max_sentiment[i])
					max_sentiment[i] = rating[i][proposal];
				
				if(rating[i][proposal] < min_sentment[i])
					min_sentment[i] = rating[i][proposal];
			}
			
		}
		
		//printf("i %d max %Le min %Le \n", i, max_sentiment[i], min_sentment[i]);
	}
}

long double CalculateGrade1to10(int i, int proposal)
{
	return round(9.0*voting_rating[i][proposal] + max_sentiment[i] - 10*min_sentment[i])/(max_sentiment[i] - min_sentment[i]);
}

long double CalculateGradeMinus10to10(int i, int proposal)
{
	return round(20.0*voting_rating[i][proposal] -10.0*(min_sentment[i] + max_sentiment[i]))/(max_sentiment[i] - min_sentment[i]);
}

long double CalculateBinaryGrade(int i, int proposal)
{
	long double y = (2.0*voting_rating[i][proposal] - (max_sentiment[i] + min_sentment[i]))/(max_sentiment[i] - min_sentment[i]);
	
	if(y < 0)
		return -1;
	
	else if (y > 0)
		return 1;
	
	else
		return (rn < 0.5)? 1: -1;
}

void CastVotesSqrtTokens()
{
	for(int proposal = 0; proposal < Nproposals; proposal++)
	{
		proposalVotes[proposal] = 0.0;
		IndividualVotes[proposal] = 0.0;
	}
	
	//calculating the average grade of each proposal
	for(int i = 0; i < N; i ++)
	{
		for(int proposal = 0; proposal < Nproposals; proposal++)
		{
			//if i has not skiped the proposal
			if(!isnan(voting_rating[i][proposal]))
			{
				//grade between 1 and 10
				int grade = CalculateGrade1to10(i, proposal);
									
				proposalVotes[proposal] += grade*sqrt(money[i]);
				
				IndividualVotes[proposal]++;
			}
		}
	}
	
	for(int proposal = 0; proposal < Nproposals; proposal++)
		proposalVotes[proposal] = proposalVotes[proposal]/totalSQRTmoney;
}

void CastBinaryVotesSqrtTokens()
{
	for(int proposal = 0; proposal < Nproposals; proposal++)
	{
		proposalVotes[proposal] = 0.0;
		IndividualVotes[proposal] = 0.0;
	}
	
	//calculating the average grade of each proposal
	for(int i = 0; i < N; i ++)
	{
		for(int proposal = 0; proposal < Nproposals; proposal++)
		{
			//if i has not skiped the proposal
			if(!isnan(voting_rating[i][proposal]))
			{
				//grade between 1 and 10
				int grade = CalculateBinaryGrade(i, proposal);
									
				proposalVotes[proposal] += grade*sqrt(money[i]);		
				
				IndividualVotes[proposal]++;
				
			}
		}
	}
	
	for(int proposal = 0; proposal < Nproposals; proposal++)
		proposalVotes[proposal] = proposalVotes[proposal]/totalSQRTmoney;
}

void CastNegativeVotesSqrtTokens()
{
	for(int proposal = 0; proposal < Nproposals; proposal++)
	{
		proposalVotes[proposal] = 0.0;
		IndividualVotes[proposal] = 0.0;
	}
	
	//calculating the average grade of each proposal
	for(int i = 0; i < N; i ++)
	{
		for(int proposal = 0; proposal < Nproposals; proposal++)
		{
			//if i has not skiped the proposal
			if(!isnan(voting_rating[i][proposal]))
			{
				//grade between -10 and 10
				int grade = CalculateGradeMinus10to10(i, proposal);
								
				proposalVotes[proposal] += grade*sqrt(money[i]);	
				
				IndividualVotes[proposal]++;
			}
		}
	}
	
	for(int proposal = 0; proposal < Nproposals; proposal++)
		proposalVotes[proposal] = proposalVotes[proposal]/totalSQRTmoney;
}

void CastVotesOneCoinOneVote()
{
	for(int proposal = 0; proposal < Nproposals; proposal++)
	{
		proposalVotes[proposal] = 0.0;
		IndividualVotes[proposal] = 0.0;
	}
	
	//calculating the average grade of each proposal
	for(int i = 0; i < N; i ++)
	{		
		for(int proposal = 0; proposal < Nproposals; proposal++)
		{
			//if i has not skiped the proposal
			if(!isnan(voting_rating[i][proposal]))
			{
				//grade between 1 and 10
				int grade = CalculateGrade1to10(i, proposal);
										
				proposalVotes[proposal] += grade*(money[i]);	
				
				IndividualVotes[proposal]++;
			}
		}
	}
	
	for(int proposal = 0; proposal < Nproposals; proposal++)
		proposalVotes[proposal] = proposalVotes[proposal]/totalMoney;
}

void CastVotesOneWalletOneVote()
{
	for(int proposal = 0; proposal < Nproposals; proposal++)
	{
		proposalVotes[proposal] = 0.0;
		IndividualVotes[proposal] = 0.0;
	}
	
	//calculating the average grade of each proposal
	for(int i = 0; i < N; i ++)
	{		
		for(int proposal = 0; proposal < Nproposals; proposal++)
		{
			//if i has not skiped the proposal
			if(!isnan(voting_rating[i][proposal]))
			{
				//grade between 1 and 10
				int grade = CalculateGrade1to10(i, proposal);
				
				proposalVotes[proposal] += grade;	
				
				IndividualVotes[proposal]++;
			}
		}
	}
	
	for(int proposal = 0; proposal < Nproposals; proposal++)
		proposalVotes[proposal] = proposalVotes[proposal]/N;
}

void GetFavoriteProposals()
{
	//we will make a list with the number of the proposal, going from the most favorite proosal to the less favorite.
	
	//first, just create the list 
	for(int i = 0; i < N; i++)
	{
		for(int proposal = 0; proposal < Nproposals; proposal++)
		{
			favoriteProposals[i][proposal] = proposal;
		}
	}
	
	//now, we make a copy of the ratings vector. We don't want to mess the original vector.
	long double copyRatings[N][Nproposals];
	for(int i = 0; i < N; i++)
	{
		for(int proposal = 0; proposal < Nproposals; proposal++)
		{
			copyRatings[i][proposal] = rating[i][proposal];
		}
		
	}
	
	//now, we will order the copy ratings vector and the index (the proposals) using bubble sort. The goal is that the first entry of the favoriteProposals will say the proposal number with the higher rating, and so on.
	for(int i = 0; i < N; i ++)
	{
		for(int p1 = 0; p1 < Nproposals - 1; p1 ++)
		{
			for(int p2 = 0; p2 < Nproposals - 1 - p1; p2++)
			{
				if(copyRatings[i][p2] < copyRatings[i][p2+1])
				{
					long double store = copyRatings[i][p2];
					copyRatings[i][p2] = copyRatings[i][p2+1];
					copyRatings[i][p2+1] = store;
					
					int storeIndex = favoriteProposals[i][p2];
					favoriteProposals[i][p2] = favoriteProposals[i][p2+1];
					favoriteProposals[i][p2+1] = storeIndex;
				}
			}
		}
	}
}

void DecideWichProjetcsToVote()
{
	//initializing
	for(int i = 0; i < N; i ++)
	{
		for(int proposal = 0; proposal < Nproposals; proposal++)
		{
			proposalsToVote[i][proposal] = -1;
		}
	}
	
	//deciding proposals will actually vote.
	//going from the most favorite proposal to the less favorite.
	for(int i = 0; i < N; i++)
	{
		int proposalIndex = 0;
		int proposalIndexVote = 0;
		while(proposalIndex < Nproposals)
		{
			int proposal = favoriteProposals[i][proposalIndex];
			
			if(!isnan(voting_rating[i][proposal]))
			{
				proposalsToVote[i][proposalIndexVote] = favoriteProposals[i][proposalIndex];
				
				proposalIndexVote++;
			}
			
			proposalIndex++;
		}
	}
}

void CastVotesPluralityVoting()
{
	GetFavoriteProposals();
	DecideWichProjetcsToVote();
	
	long double proposalVoteWeight[Nproposals];
	
	for(int proposal = 0; proposal < Nproposals; proposal++)
	{
		proposalVotes[proposal] = 0.0;
		proposalVoteWeight[proposal] = 0.0;
		
		IndividualVotes[proposal] = 0.0;
	}
	
	for(int i = 0; i < N; i ++)
	{
		long double totalGradeWeight = 0;
		
		int proposalIndex = 0;
		while(proposalIndex < Nproposals && proposalsToVote[i][proposalIndex] != -1)
		{
			int proposal = proposalsToVote[i][proposalIndex];
			
			totalGradeWeight += LinearGradeWeight(CalculateGrade1to10(i, proposal));;		
			
			proposalIndex++;
		}
				
		if(totalGradeWeight)
		{
			int proposalIndex = 0;
			while(proposalIndex < Nproposals && proposalsToVote[i][proposalIndex] != -1)
			{
				int proposal = proposalsToVote[i][proposalIndex];
				
				long double grade = CalculateGrade1to10(i, proposal);
				
				long double weightGrade = LinearGradeWeight(grade);
				
				proposalVotes[proposal] += grade*sqrt(weightGrade*money[i]/totalGradeWeight);
				
				proposalVoteWeight[proposal] += sqrt(weightGrade*money[i]/totalGradeWeight);
				
				IndividualVotes[proposal]++;
				
				proposalIndex++;
			}
		}
	}
	
	for(int proposal = 0; proposal < Nproposals; proposal++)
		proposalVotes[proposal] = proposalVotes[proposal]/proposalVoteWeight[proposal];
}

void CastVotesUnboundedPluralityVoting()
{
	GetFavoriteProposals();
	DecideWichProjetcsToVote();
	
	long double proposalVoteWeight[Nproposals];
	
	for(int proposal = 0; proposal < Nproposals; proposal++)
	{
		proposalVotes[proposal] = 0.0;
		
		IndividualVotes[proposal] = 0.0;
		
		MoneyPercent[proposal] = 0.0;
	}
	
	for(int i = 0; i < N; i ++)
	{		
		long double totalOpinion = 0.0;
		for(int proposal = 0; proposal < Nproposals; proposal++)
		{
			if(voting_rating[i][proposal] > 0)
				totalOpinion += voting_rating[i][proposal];
		}
		
		if(!isnan(totalOpinion) && totalOpinion > 0)
		{
			int proposalIndex = 0;
			while(proposalIndex < Nproposals && proposalsToVote[i][proposalIndex] != -1)
			{
				int proposal = proposalsToVote[i][proposalIndex];
				
				if(voting_rating[i][proposal] > 0)
				{
					proposalVotes[proposal] += sqrt(voting_rating[i][proposal]*money[i]/totalOpinion);
					
					IndividualVotes[proposal]++;
					
					MoneyPercent[proposal] += voting_rating[i][proposal]/totalOpinion;
				}
				
				proposalIndex++;
			}
		}
	}
	
	for(int proposal = 0; proposal < Nproposals; proposal++)
		MoneyPercent[proposal] = MoneyPercent[proposal]/N;
}

double sign(long double x) 
{
	if (x > 0) 
		return 1;
	
	else if (x < 0) 
		return -1;
	
	else 
		return 0;
}

void CastVotesUnboundedPluralityVotingWithNegatives()
{
	GetFavoriteProposals();
	DecideWichProjetcsToVote();
	
	long double proposalVoteWeight[Nproposals];
	
	for(int proposal = 0; proposal < Nproposals; proposal++)
	{
		proposalVotes[proposal] = 0.0;
		IndividualVotes[proposal] = 0.0;
		
		MoneyPercent[proposal] = 0.0;
	}
	
	for(int i = 0; i < N; i ++)
	{		
		long double totalOpinion = 0.0;
		for(int proposal = 0; proposal < Nproposals; proposal++)
		{
			totalOpinion += fabsl(voting_rating[i][proposal]);
		}
		
		if(!isnan(totalOpinion) && totalOpinion > 0)
		{
			int proposalIndex = 0;
			while(proposalIndex < Nproposals && proposalsToVote[i][proposalIndex] != -1)
			{
				int proposal = proposalsToVote[i][proposalIndex];
				
				proposalVotes[proposal] += sign(voting_rating[i][proposal])*sqrt(fabsl(voting_rating[i][proposal])*money[i]/totalOpinion);
				
				IndividualVotes[proposal]++;
				
				proposalIndex++;
				
				if(sign(voting_rating[i][proposal]) > 0)
					MoneyPercent[proposal] += (voting_rating[i][proposal])/totalOpinion;
			}			
		}
	}
	
	for(int proposal = 0; proposal < Nproposals; proposal++)
		MoneyPercent[proposal] = MoneyPercent[proposal]/N;
}

void CastVotesPluralityVotingWithNegatives()
{
	GetFavoriteProposals();
	DecideWichProjetcsToVote();
	
	long double proposalVoteWeight[Nproposals];
	
	for(int proposal = 0; proposal < Nproposals; proposal++)
	{
		proposalVotes[proposal] = 0.0;
		proposalVoteWeight[proposal] = 0.0;
		
		IndividualVotes[proposal] = 0.0;
	}
	
	for(int i = 0; i < N; i ++)
	{
		long double totalGradeWeight = 0;
		
		int proposalIndex = 0;
		while(proposalIndex < Nproposals && proposalsToVote[i][proposalIndex] != -1)
		{
			int proposal = proposalsToVote[i][proposalIndex];
			
			totalGradeWeight += LinearGradeWeightWithNegatives(CalculateGradeMinus10to10(i, proposal));;		
			
			proposalIndex++;
		}
				
		if(totalGradeWeight)
		{
			int proposalIndex = 0;
			while(proposalIndex < Nproposals && proposalsToVote[i][proposalIndex] != -1)
			{
				int proposal = proposalsToVote[i][proposalIndex];
				
				long double grade = CalculateGradeMinus10to10(i, proposal);
				
				long double weightGrade = LinearGradeWeightWithNegatives(grade);
				
				proposalVotes[proposal] += grade*sqrt(weightGrade*money[i]/totalGradeWeight);
				
				proposalVoteWeight[proposal] += sqrt(weightGrade*money[i]/totalGradeWeight);
				
				IndividualVotes[proposal]++;
				
				proposalIndex++;
			}
		}
	}
	
	for(int proposal = 0; proposal < Nproposals; proposal++)
		proposalVotes[proposal] = proposalVotes[proposal]/proposalVoteWeight[proposal];

}

void CastQuadraticVotesPluralityVotingWithNegatives()
{
	GetFavoriteProposals();
	DecideWichProjetcsToVote();
	
	long double proposalVoteWeight[Nproposals];
	
	for(int proposal = 0; proposal < Nproposals; proposal++)
	{
		proposalVotes[proposal] = 0.0;
		proposalVoteWeight[proposal] = 0.0;
		
		IndividualVotes[proposal] = 0.0;
	}
	
	for(int i = 0; i < N; i ++)
	{
		long double totalGradeWeight = 0;
		
		int proposalIndex = 0;
		while(proposalIndex < Nproposals && proposalsToVote[i][proposalIndex] != -1)
		{
			int proposal = proposalsToVote[i][proposalIndex];
			
			totalGradeWeight += QuadraticGradeWeightWithNegatives(CalculateGradeMinus10to10(i, proposal));;		
			
			proposalIndex++;
		}
				
		if(totalGradeWeight)
		{
			int proposalIndex = 0;
			while(proposalIndex < Nproposals && proposalsToVote[i][proposalIndex] != -1)
			{
				int proposal = proposalsToVote[i][proposalIndex];
				
				long double grade = CalculateGradeMinus10to10(i, proposal);
				
				long double weightGrade = QuadraticGradeWeightWithNegatives(grade);
				
				proposalVotes[proposal] += grade*sqrt(weightGrade*money[i]/totalGradeWeight);
				
				proposalVoteWeight[proposal] += sqrt(weightGrade*money[i]/totalGradeWeight);
				
				IndividualVotes[proposal]++;
				
				proposalIndex++;
				
			}
		}
	}
	
	for(int proposal = 0; proposal < Nproposals; proposal++)
		proposalVotes[proposal] = proposalVotes[proposal]/proposalVoteWeight[proposal];

}

void CastQuadraticVotesPluralityVoting()
{
	GetFavoriteProposals();
	DecideWichProjetcsToVote();
	
	long double proposalVoteWeight[Nproposals];
	
	for(int proposal = 0; proposal < Nproposals; proposal++)
	{
		proposalVotes[proposal] = 0.0;
		proposalVoteWeight[proposal] = 0.0;
		
		IndividualVotes[proposal] = 0.0;
	}
	
	for(int i = 0; i < N; i ++)
	{
		long double totalGradeWeight = 0;
		
		int proposalIndex = 0;
		while(proposalIndex < Nproposals && proposalsToVote[i][proposalIndex] != -1)
		{
			int proposal = proposalsToVote[i][proposalIndex];
			
			totalGradeWeight += QuadraticGradeWeight(CalculateGrade1to10(i, proposal));;		
			
			proposalIndex++;
		}
				
		if(totalGradeWeight)
		{
			int proposalIndex = 0;
			while(proposalIndex < Nproposals && proposalsToVote[i][proposalIndex] != -1)
			{
				int proposal = proposalsToVote[i][proposalIndex];
				
				long double grade = CalculateGrade1to10(i, proposal);
				
				long double weightGrade = QuadraticGradeWeight(grade);
				
				proposalVotes[proposal] += grade*sqrt(weightGrade*money[i]/totalGradeWeight);
				
				proposalVoteWeight[proposal] += sqrt(weightGrade*money[i]/totalGradeWeight);
				
				IndividualVotes[proposal]++;
				
				proposalIndex++;
			}
		}
	}
	
	for(int proposal = 0; proposal < Nproposals; proposal++)
		proposalVotes[proposal] = proposalVotes[proposal]/proposalVoteWeight[proposal];

}

void GetMostVotedProposals()
{
	//we will make a list with the number of the proposal, going from the most voted proosal to the less voted.
	//first, just create the list 
	for(int proposal = 0; proposal < Nproposals; proposal++)
	{
		MostVotedProposals[proposal] = proposal;
	}
	
	//printf("start \n");
	
	//now, we make a copy of the proposalvotes vector. We don't want to mess the original vector.
	long double copyVotes[Nproposals];
	for(int proposal = 0; proposal < Nproposals; proposal++)
	{
		copyVotes[proposal] = proposalVotes[proposal];
		//printf("prop %d votes %Lf \n", proposal, proposalVotes[proposal]);
	}

	//now, we will order the copy votes vector and the index (the proposals) using bubble sort. The goal is that the first entry of the MostVotedProposals will say the proposal number with most votes, and so on.
	for(int i = 0; i < Nproposals - 1; i ++)
	{
		for(int j = 0; j < Nproposals - 1 - i; j++)
		{
			if(copyVotes[j] < copyVotes[j+1])
			{
				long double store = copyVotes[j];
				copyVotes[j] = copyVotes[j+1];
				copyVotes[j+1] = store;
				
				int storeIndex = MostVotedProposals[j];
				MostVotedProposals[j] = MostVotedProposals[j+1];
				MostVotedProposals[j+1] = storeIndex;
			}
		}
	}
}

void GetAwardedProposals()
{
	//first, we need to determine the eligible proposals. Eligible porposals must have received votes from at least 1% of the voters.	
	//the project also needs a minimum average grad of 6.5 and must fit the pools remaining budget after higher voter proposals are funded.
	long double MoneyAvailableToFund = fundingMoney;
	NfundedProposals = 0;
	
	//from the most voted proposal to the less voted proposal
	for(int j = 0; j < Nproposals; j++)
	{
		int proposal = MostVotedProposals[j];
		
		//check if proposal is eligible
		if(proposalVotes[proposal] >= 6.5 && (long double)IndividualVotes[proposal] >= 0.01*N)
		{
			//if there is suficient funding money to fund the proposal
			if(funding[proposal] <= MoneyAvailableToFund)
				{
					fundedProposals[NfundedProposals] = proposal;
					NfundedProposals++;
					MoneyAvailableToFund = MoneyAvailableToFund - funding[proposal];
				}
		}
	}
}

void GetUnboudedAwardedProposals()
{
	//first, we need to determine the eligible proposals. Eligible porposals must have received votes from at least 1% of the voters.	
	//the project also needs a minimum average grad of 6.5 and must fit the pools remaining budget after higher voter proposals are funded.
	long double MoneyAvailableToFund = fundingMoney;
	NfundedProposals = 0;
	
	//from the most voted proposal to the less voted proposal
	for(int j = 0; j < Nproposals; j++)
	{
		int proposal = MostVotedProposals[j];
		
		//check if proposal is eligible
		if(MoneyPercent[proposal] >= 0.05 && (long double)IndividualVotes[proposal] >= 0.01*N)
		{
			//if there is suficient funding money to fund the proposal
			if(funding[proposal] <= MoneyAvailableToFund)
			{
				fundedProposals[NfundedProposals] = proposal;
				NfundedProposals++;
				MoneyAvailableToFund = MoneyAvailableToFund - funding[proposal];
			}
		}
	}
}
void GetBinaryAwardedProposals()
{
	//first, we need to determine the eligible proposals. Eligible porposals must have received votes from at least 1% of the voters.	
	//the project also needs a minimum average grad of 6.5 and must fit the pools remaining budget after higher voter proposals are funded.
	long double MoneyAvailableToFund = fundingMoney;
	NfundedProposals = 0;
	
	//from the most voted proposal to the less voted proposal
	for(int j = 0; j < Nproposals; j++)
		{
			int proposal = MostVotedProposals[j];
			
			//check if proposal is eligible
			if(proposalVotes[proposal] >= 0.65 && (long double)IndividualVotes[proposal] >= 0.01*N)
				{
					//if there is suficient funding money to fund the proposal
					if(funding[proposal] <= MoneyAvailableToFund)
						{
							fundedProposals[NfundedProposals] = proposal;
							NfundedProposals++;
							MoneyAvailableToFund = MoneyAvailableToFund - funding[proposal];
						}
				}
		}
}

int proposalIsFunded(int proposal)
{
	for(int j = 0; j < NfundedProposals; j++)
	{
		if(proposal == fundedProposals[j])
			return 1;
	}
	
	return 0;
}

void welfare()
{	
	W = 0.0;
	long double normalization_factor = 0.0;
	//long double totalNumberVoters = 0;
	
	for(int proposal = 0; proposal < Nproposals; proposal++)
	{
		//for each funded proposal, we calculate the welfare of this proposal on the population.
		for(int i = 0; i < N; i ++)
		{
			//we assume if i skiped the proposal, he/she is indiferent to the proposal, and has no welfare to that proposal.
			if(!isnan(rating[i][proposal]))
			{
				normalization_factor += fabsl(rating[i][proposal]);
				//totalNumberVoters ++;
						
				if(proposalIsFunded(proposal))
					W += rating[i][proposal];
				
				else
					W -= rating[i][proposal];
			}
		}
	}
	
	if(NfundedProposals)
		W = W/normalization_factor;
		
	else
		W = 0.0;	
}

void welfareStrategicAgents()
{	
	W = 0.0;
	long double normalization_factor = 0.0;
	//long double totalNumberVoters = 0;
	
	for(int proposal = 0; proposal < Nproposals; proposal++)
	{
		//for each funded proposal, we calculate the welfare of this proposal on the population.
		for(int i = 0; i < N; i ++)
		{
			//we assume if i skiped the proposal, he/she is indiferent to the proposal, and has no welfare to that proposal.
			if(agentType[i]==1 && !isnan(rating[i][proposal]))
			{
				normalization_factor += fabsl(rating[i][proposal]);
				//totalNumberVoters ++;
						
				if(proposalIsFunded(proposal))
					W += rating[i][proposal];
				
				else
					W -= rating[i][proposal];
			}
		}
	}
	
	if(NfundedProposals)
		W = W/normalization_factor;
		
	else
		W = 0.0;	
}

void welfareNonStrategicAgents()
{	
	W = 0.0;
	long double normalization_factor = 0.0;
	//long double totalNumberVoters = 0;
	
	for(int proposal = 0; proposal < Nproposals; proposal++)
	{
		//for each funded proposal, we calculate the welfare of this proposal on the population.
		for(int i = 0; i < N; i ++)
		{
			//we assume if i skiped the proposal, he/she is indiferent to the proposal, and has no welfare to that proposal.
			if(agentType[i]==0 && !isnan(rating[i][proposal]))
			{
				normalization_factor += fabsl(rating[i][proposal]);
				//totalNumberVoters ++;
						
				if(proposalIsFunded(proposal))
					W += rating[i][proposal];
				
				else
					W -= rating[i][proposal];
			}
		}
	}
	
	if(NfundedProposals)
		W = W/normalization_factor;
		
	else
		W = 0.0;	
}

int effectiveAmt(long double variable)
{
	int effectiveAmt = backUpRate;
	
	//find name of txt
	char txtname [200];
	sprintf(txtname, "%s", "Variable");
	char txtname2 [200];
	sprintf(txtname2, "(%.4Le)", variable);
	strcat(txtname, txtname2);
	char final [200] = ".txt";
	strcat(txtname, final);
	
	//open the file
	read = fopen(txtname, "r");
	
	//check if file exists
	if(read == NULL)
		printf("file can't be opened.\n");
	
	//extract characters from file until end of the file (EOF)
	for (character = getc(read); character != EOF; character = getc(read))
		//increment counter if we find new line
	if(character == '\n')
		effectiveAmt +=backUpRate;
	
	//close the file
	fclose(read);
	
	return effectiveAmt;
}

void SIMULATION(long double variablei, long double variablef, long double dvariable)
{
	//defining the stage points
	struct STAGE POINT; 
	
	//determining the stage of the simulation with the parameters
	POINT = POINTS(variablei, variablef, dvariable, Nstages);
	
	float Nbackups = (float)Nxps/backUpRate;
	for(int backup = 1; backup <= Nbackups; backup++)
	{
		f = POINT.INITIAL;
		for(int step = 0; step <= (POINT.FINAL-POINT.INITIAL)/dvariable; step++)
		{
			//arquive
			sprintf(txt, "Variable(%.4Le).txt", f);
			fp = fopen(txt, "a");
			
			//find effective sample
			int totalAmt = effectiveAmt(f);
			
			long double Wext[Kf], WextStrategic[Kf], WextNonStrategic[Kf];
			long double WextSkip[Kf], WextSkipStrategic[Kf], WextSkipNonStrategic[Kf];
			long double Weco[Kf], WecoStrategic[Kf], WecoNonStrategic[Kf];
			long double WecoExtreme[Kf], WecoExtremeStrategic[Kf], WecoExtremeNonStrategic[Kf];
				
			//initializing the means
			WextFully = 0.0; WextFullyStrategic = 0.0; WextFullyNonstrategic = 0.0;
			WextFullySkip = 0.0; WextFullySkipStrategic = 0.0; WextFullySkipNonstrategic = 0.0;
			for(int K = Ki; K <= Kf; K++)
			{
				Wext[K] = 0;
				WextStrategic[K] = 0;
				WextNonStrategic[K] = 0;
				
				WextSkip[K] = 0;
				WextSkipStrategic[K] = 0;
				WextSkipNonStrategic[K] = 0;
				
				Weco[K] = 0;
				WecoStrategic[K] = 0;
				WecoNonStrategic[K] = 0;
				
				WecoExtreme[K] = 0;
				WecoExtremeStrategic[K] = 0;
				WecoExtremeNonStrategic[K] = 0;
			}
			
			for(int xp = 0; xp < backUpRate; xp++)
			{
				Money_Distribution();
				RequestFundingDistribution();
				InertiaDistribution();
				ProposalDynamics();
				FindMaximumSentments();
				
				for(int K = Ki; K <= Kf; K++)
				{
					AgentsDistributionExtreme(K);
					CastVotesOneCoinOneVote();
					GetMostVotedProposals();
					GetAwardedProposals();
					welfare();
					Wext[K] += W;
					welfareStrategicAgents();
					WextStrategic[K] += W;
					welfareNonStrategicAgents();
					WextNonStrategic[K] += W;
					
					AgentsDistributionExtremeSkip(K);
					CastVotesOneCoinOneVote();
					GetMostVotedProposals();
					GetAwardedProposals();
					welfare();
					WextSkip[K] += W;
					welfareStrategicAgents();
					WextSkipStrategic[K] += W;
					welfareNonStrategicAgents();
					WextSkipNonStrategic[K] += W;
					
					AgentsDistributionEconomist(K);
					CastVotesOneCoinOneVote();
					GetMostVotedProposals();
					GetAwardedProposals();
					welfare();
					Weco[K] += W;
					welfareStrategicAgents();
					WecoStrategic[K] += W;
					welfareNonStrategicAgents();
					WecoNonStrategic[K] += W;
					
					AgentsDistributionEconomistExtreme(K);
					CastVotesOneCoinOneVote();
					GetMostVotedProposals();
					GetAwardedProposals();
					welfare();
					WecoExtreme[K] += W;
					welfareStrategicAgents();
					WecoExtremeStrategic[K] += W;
					welfareNonStrategicAgents();
					WecoExtremeNonStrategic[K] += W;
				}
				
				AgentsDistributionFullyExtreme();
				CastVotesOneCoinOneVote();
				GetMostVotedProposals();
				GetAwardedProposals();
				welfare();
				WextFully += W;
				welfareStrategicAgents();
				WextFullyStrategic += W;
				welfareNonStrategicAgents();
				WextFullyNonstrategic += W;
				
				AgentsDistributionFullyExtremeSkip();
				CastVotesOneCoinOneVote();
				GetMostVotedProposals();
				GetAwardedProposals();
				welfare();
				WextFullySkip += W;
				welfareStrategicAgents();
				WextFullySkipStrategic += W;
				welfareNonStrategicAgents();
				WextFullySkipNonstrategic += W;
				
				
//				CastVotesOneCoinOneVote();
//				GetMostVotedProposals();
//				GetAwardedProposals();
//				welfare();
//				WoneCoinSum += W;
//				
//				CastVotesOneWalletOneVote();
//				GetMostVotedProposals();
//				GetAwardedProposals();
//				welfare();
//				WoneWalletSum += W;
//				
//				CastVotesPluralityVoting();
//				GetMostVotedProposals();
//				GetAwardedProposals();
//				welfare();
//				WpluralitySum += W;
//				
//				CastQuadraticVotesPluralityVoting();
//				GetMostVotedProposals();
//				GetAwardedProposals();
//				welfare();
//				WquadraticPluralitySum += W;
//				
//				CastVotesPluralityVotingWithNegatives();
//				GetMostVotedProposals();
//				GetAwardedProposals();
//				welfare();
//				WNegativePluralitySum += W;
//				
//				CastQuadraticVotesPluralityVotingWithNegatives();
//				GetMostVotedProposals();
//				GetAwardedProposals();
//				welfare();
//				WquadraticNegativePluralitySum += W;
//				
//				CastBinaryVotesSqrtTokens();
//				GetMostVotedProposals();
//				GetBinaryAwardedProposals();
//				welfare();
//				WbinarySqrtSum += W;
//				
//				CastNegativeVotesSqrtTokens();
//				GetMostVotedProposals();
//				GetAwardedProposals();
//				welfare();
//				WnegativeSqrtSum += W;
//				
//				CastVotesUnboundedPluralityVoting();
//				GetMostVotedProposals();
//				GetUnboudedAwardedProposals();
//				welfare();
//				WpluralityUnbounded += W;
//				
//				CastVotesUnboundedPluralityVotingWithNegatives();
//				GetMostVotedProposals();
//				GetUnboudedAwardedProposals();
//				welfare();
//				WpluralityUnboundedNegative += W;
			}
			
			WextFully = WextFully/backUpRate; 
			WextFullyStrategic = WextFullyStrategic/backUpRate;
			WextFullyNonstrategic = WextFullyNonstrategic/backUpRate;
			
			WextFullySkip = WextFullySkip/backUpRate;
			WextFullySkipStrategic = WextFullySkipStrategic/backUpRate;
			WextFullySkipNonstrategic = WextFullySkipNonstrategic/backUpRate;
			for(int K = Ki; K <= Kf; K++)
			{
				Wext[K] = Wext[K]/backUpRate;
				WextStrategic[K] = WextStrategic[K]/backUpRate;
				WextNonStrategic[K] = WextNonStrategic[K]/backUpRate;
				
				WextSkip[K] = WextSkip[K]/backUpRate;
				WextSkipStrategic[K] = WextSkipStrategic[K]/backUpRate;
				WextSkipNonStrategic[K] = WextSkipNonStrategic[K]/backUpRate;
				
				Weco[K] = Weco[K]/backUpRate;
				WecoStrategic[K] = WecoStrategic[K]/backUpRate;
				WecoNonStrategic[K] = WecoNonStrategic[K]/backUpRate;
				
				WecoExtreme[K] = WecoExtreme[K]/backUpRate;
				WecoExtremeStrategic[K] = WecoExtremeStrategic[K]/backUpRate;
				WecoExtremeNonStrategic[K] = WecoExtremeNonStrategic[K]/backUpRate;
			}

			//we write the results the average result of this samples
			fp = fopen(txt, "a");
			
			for(int K = Ki; K <= Kf; K++)
				fprintf (fp, "%Le\t", Wext[K]);
			for(int K = Ki; K <= Kf; K++)
				fprintf (fp, "%Le\t", WextSkip[K]);
			for(int K = Ki; K <= Kf; K++)
				fprintf (fp, "%Le\t", Weco[K]);
			for(int K = Ki; K <= Kf; K++)
				fprintf (fp, "%Le\t", WecoExtreme[K]);
			fprintf (fp, "%Le\t", WextFully);
			fprintf (fp, "%Le\t", WextFullySkip);
			
			
			for(int K = Ki; K <= Kf; K++)
				fprintf (fp, "%Le\t", WextStrategic[K]);
			for(int K = Ki; K <= Kf; K++)
				fprintf (fp, "%Le\t", WextSkipStrategic[K]);
			for(int K = Ki; K <= Kf; K++)
				fprintf (fp, "%Le\t", WecoStrategic[K]);
			for(int K = Ki; K <= Kf; K++)
				fprintf (fp, "%Le\t", WecoExtremeStrategic[K]);
			fprintf (fp, "%Le\t", WextFullyStrategic);
			fprintf (fp, "%Le\t", WextFullySkipStrategic);
			
			for(int K = Ki; K <= Kf; K++)
				fprintf (fp, "%Le\t", WextNonStrategic[K]);
			for(int K = Ki; K <= Kf; K++)
				fprintf (fp, "%Le\t", WextSkipNonStrategic[K]);
			for(int K = Ki; K <= Kf; K++)
				fprintf (fp, "%Le\t", WecoNonStrategic[K]);
			for(int K = Ki; K <= Kf; K++)
				fprintf (fp, "%Le\t", WecoExtremeNonStrategic[K]);
			fprintf (fp, "%Le\t", WextFullyNonstrategic);
			fprintf (fp, "%Le\t", WextFullySkipNonstrategic);
			
			fprintf (fp, "%d\t",  totalAmt);
			
			fprintf(fp, "\n");
			
			fclose(fp);
			
			//improving effective sample
			totalAmt+=backUpRate;
			
			f += dvariable;
		}
	}
}	

//function to sum the values at a given column of a txt file
long double sumColumnK(const char* filename, int Ncolumns, int targetColumn) 
{
	FILE* file = fopen(filename, "r");
	if (file == NULL)
	{
		printf("Error opening file: %s\n", filename);
		return 0.0;
	}
	
	double combine = 0.0;
	int xp = 0;
	int column = 1;
	double value;
	while (fscanf(file, "%lf", &value) == 1) 
	{
		if (column == targetColumn) 
		{
			combine += value;
			xp++;
		}
		
		column++;
		if (column > Ncolumns) 
		{
			column = 1;
		}
	}
	fclose(file);
	
	return combine = combine/xp;
}

//here we combined the data on the txts files to get the average results of all the samples.
void Combine(long double variable, long double variablei, long double variablef, long double dvariable)
{
	system("clear");
	printf("Combining txt files...\n");
	
	int Npoints = (int)((variablef - variablei)/dvariable) + 1;

	//writing arquive
	sprintf(write, "CombinedData.txt");
	
	fp = fopen(write, "w");
	
	fprintf (fp, "f\t");
	
	for(int K = Ki; K <= Kf; K++)
		fprintf (fp, "Wext%d\t", K);
	for(int K = Ki; K <= Kf; K++)
		fprintf (fp, "WextSkip%d\t", K);
	for(int K = Ki; K <= Kf; K++)
		fprintf (fp, "Wco%d\t", K);
	for(int K = Ki; K <= Kf; K++)
		fprintf (fp, "WecoExtreme%d\t", K);
	fprintf (fp, "Wextfully\t");
	fprintf (fp, "WextfullySkip\t");
	
	for(int K = Ki; K <= Kf; K++)
		fprintf (fp, "WextStrategic%d\t", K);
	for(int K = Ki; K <= Kf; K++)
		fprintf (fp, "WextSkipStrategic%d\t", K);
	for(int K = Ki; K <= Kf; K++)
		fprintf (fp, "WecoStrategic%d\t", K);
	for(int K = Ki; K <= Kf; K++)
		fprintf (fp, "WecoExtremeStrategic%d\t", K);
	fprintf (fp, "WextfullyStrategic\t");
	fprintf (fp, "WextFullySkipStrategic\t");
	
	for(int K = Ki; K <= Kf; K++)
		fprintf (fp, "WextNonStrategic%d\t", K);
	for(int K = Ki; K <= Kf; K++)
		fprintf (fp, "WextSkipNonStrategic%d\t", K);
	for(int K = Ki; K <= Kf; K++)
		fprintf (fp, "WecoNonStrategic%d\t", K);
	for(int K = Ki; K <= Kf; K++)
		fprintf (fp, "WecoExtremeNonStrategic%d\t", K);
	fprintf (fp, "WextfullyNonstrategic\t");
	fprintf (fp, "WextfullySkipNonstrategic\t");

	fprintf(fp, "\n");	
	fclose(fp);
	
	//opening the files to read
	variable = variablei;
	for(int i=0; i <= Npoints; i++)
	{
		//find name of txt
		char txtname [200];
		sprintf(txtname, "%s", "Variable");
		char txtname2 [200];
		sprintf(txtname2, "(%.4Le)", variable);
		strcat(txtname, txtname2);
		char final [200] = ".txt";
		strcat(txtname, final);
				
		//writing data
		fp = fopen(write, "a");
		fprintf(fp, "%Le \t", variable);
		fclose(fp);
		
		//combining data
		int numberColumns = 12*Kf + 7;
		int initialColumnCombine = 1, finalColumnCombine = 12*Kf + 6;
		for(int column = initialColumnCombine; column <= finalColumnCombine; column++)
		{
			long double combine = sumColumnK(txtname, numberColumns, column);
			
			if(!isnan(combine))
			{
				//writing result averaged data
				fp = fopen(write, "a");
				fprintf(fp, "%Le \t", combine);
				fclose(fp);
			}
			
			else
			{
				//writing result averaged data
				fp = fopen(write, "a");
				fprintf(fp, "0.0 \t");
				fclose(fp);
				
			}
		}
		fp = fopen(write, "a");
		fprintf(fp, "\n");
		fclose(fp);
		
		variable +=dvariable;
	}
	printf("...Done!");
}

void SimulationMenu(float variable, float variablei, float variablef, float dvariable)
{
	//system("clear");
	printf("Hello, welcome to the simulator! \n\nTo simulate, insert 1. \nTo combine txt simulation files, insert 2. \nTo exit, insert anything else. \n\nInsert here:");
	int insert;
	scanf("%d", &insert);
	
	if(insert == 1)
		SIMULATION(variablei, variablef, dvariable);
	else if(insert == 2)
		Combine(variable, variablei, variablef, dvariable);
}

int main(void)
{ 
	//using time as seed for the random number generator     
    srand(time(NULL));
    	
	//starting!!
	printf("-Program started!\n");
	
	//executing the program!
	SimulationMenu(f, fi, ff, df);
	//remember to manually insert the changing
	//variable in the simulation function!!!

	//finished!!
	printf("-Program finished:)\n");
	
    //goodbye                
    return 0;

	//praised be God!!!
}
	
	
	
	
